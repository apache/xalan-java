<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_391) on Sun Jun 22 16:12:14 IST 2025 -->
<title>CoroutineManager</title>
<meta name="date" content="2025-06-22">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="CoroutineManager";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../../../org/apache/xml/dtm/ref/CoroutineParser.html" title="interface in org.apache.xml.dtm.ref"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?org/apache/xml/dtm/ref/CoroutineManager.html" target="_top">Frames</a></li>
<li><a href="CoroutineManager.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.apache.xml.dtm.ref</div>
<h2 title="Class CoroutineManager" class="title">Class CoroutineManager</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>org.apache.xml.dtm.ref.CoroutineManager</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="typeNameLabel">CoroutineManager</span>
extends java.lang.Object</pre>
<div class="block"><p>Support the coroutine design pattern.</p>
 
 <p>A coroutine set is a very simple cooperative non-preemptive
 multitasking model, where the switch from one task to another is
 performed via an explicit request. Coroutines interact according to
 the following rules:</p>

 <ul>
 <li>One coroutine in the set has control, which it retains until it
 either exits or resumes another coroutine.</li>
 <li>A coroutine is activated when it is resumed by some other coroutine
 for the first time.</li>
 <li>An active coroutine that gives up control by resuming another in
 the set retains its context -- including call stack and local variables
 -- so that if/when it is resumed, it will proceed from the point at which
 it last gave up control.</li>
 </ul>

 <p>Coroutines can be thought of as falling somewhere between pipes and
 subroutines. Like call/return, there is an explicit flow of control
 from one coroutine to another. Like pipes, neither coroutine is
 actually "in charge", and neither must exit in order to transfer
 control to the other. </p>
 
 <p>One classic application of coroutines is in compilers, where both
 the parser and the lexer are maintaining complex state
 information. The parser resumes the lexer to process incoming
 characters into lexical tokens, and the lexer resumes the parser
 when it has reached a point at which it has a reliably interpreted
 set of tokens available for semantic processing. Structuring this
 as call-and-return would require saving and restoring a
 considerable amount of state each time. Structuring it as two tasks
 connected by a queue may involve higher overhead (in systems which
 can optimize the coroutine metaphor), isn't necessarily as clear in
 intent, may have trouble handling cases where data flows in both
 directions, and may not handle some of the more complex cases where
 more than two coroutines are involved.</p>
 
 <p>Most coroutine systems also provide a way to pass data between the
 source and target of a resume operation; this is sometimes referred
 to as "yielding" a value.  Others rely on the fact that, since only
 one member of a coroutine set is running at a time and does not
 lose control until it chooses to do so, data structures may be
 directly shared between them with only minimal precautions.</p>
 
 <p>"Note: This should not be taken to mean that producer/consumer
 problems should be always be done with coroutines." Queueing is
 often a better solution when only two threads of execution are
 involved and full two-way handshaking is not required. It's a bit
 difficult to find short pedagogical examples that require
 coroutines for a clear solution.</p>
 
 <p>The fact that only one of a group of coroutines is running at a
 time, and the control transfer between them is explicit, simplifies
 their possible interactions, and in some implementations permits
 them to be implemented more efficiently than general multitasking.
 In some situations, coroutines can be compiled out entirely;
 in others, they may only require a few instructions more than a
 simple function call.</p>

 <p>This version is built on top of standard Java threading, since
 that's all we have available right now. It's been encapsulated for
 code clarity and possible future optimization.</p>
 
 <p>(Two possible approaches: wait-notify based and queue-based. Some
 folks think that a one-item queue is a cleaner solution because it's
 more abstract -- but since coroutine _is_ an abstraction I'm not really
 worried about that; folks should be able to switch this code without
 concern.)</p>
 
 <p>%TBD% THIS SHOULD BE AN INTERFACE, to facilitate building other
 implementations... perhaps including a true coroutine system
 someday, rather than controlled threading. Arguably Coroutine
 itself should be an interface much like Runnable, but I think that
 can be built on top of this.</p></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../../../org/apache/xml/dtm/ref/CoroutineManager.html#CoroutineManager--">CoroutineManager</a></span>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/xml/dtm/ref/CoroutineManager.html#co_entry_pause-int-">co_entry_pause</a></span>(int&nbsp;thisCoroutine)</code>
<div class="block">In the standard coroutine architecture, coroutines are
 identified by their method names and are launched and run up to
 their first yield by simply resuming them; its's presumed that
 this recognizes the not-already-running case and does the right
 thing.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/xml/dtm/ref/CoroutineManager.html#co_exit_to-java.lang.Object-int-int-">co_exit_to</a></span>(java.lang.Object&nbsp;arg_object,
          int&nbsp;thisCoroutine,
          int&nbsp;toCoroutine)</code>
<div class="block">Make the ID available for reuse and terminate this coroutine,
 transferring control to the specified coroutine.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/xml/dtm/ref/CoroutineManager.html#co_exit-int-">co_exit</a></span>(int&nbsp;thisCoroutine)</code>
<div class="block">Terminate this entire set of coroutines.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/xml/dtm/ref/CoroutineManager.html#co_joinCoroutineSet-int-">co_joinCoroutineSet</a></span>(int&nbsp;coroutineID)</code>
<div class="block">Each coroutine in the set managed by a single
 CoroutineManager is identified by a small positive integer.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/xml/dtm/ref/CoroutineManager.html#co_resume-java.lang.Object-int-int-">co_resume</a></span>(java.lang.Object&nbsp;arg_object,
         int&nbsp;thisCoroutine,
         int&nbsp;toCoroutine)</code>
<div class="block">Transfer control to another coroutine which has already been started and
 is waiting on this CoroutineManager.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="CoroutineManager--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>CoroutineManager</h4>
<pre>public&nbsp;CoroutineManager()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="co_joinCoroutineSet-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>co_joinCoroutineSet</h4>
<pre>public&nbsp;int&nbsp;co_joinCoroutineSet(int&nbsp;coroutineID)</pre>
<div class="block"><p>Each coroutine in the set managed by a single
 CoroutineManager is identified by a small positive integer. This
 brings up the question of how to manage those integers to avoid
 reuse... since if two coroutines use the same ID number, resuming
 that ID could resume either. I can see arguments for either
 allowing applications to select their own numbers (they may want
 to declare mnemonics via manefest constants) or generating
 numbers on demand.  This routine's intended to support both
 approaches.</p>

 <p>%REVIEW% We could use an object as the identifier. Not sure
 it's a net gain, though it would allow the thread to be its own
 ID. Ponder.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>coroutineID</code> - If >=0, requests that we reserve this number.
 If <0, requests that we find, reserve, and return an available ID
 number.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>If >=0, the ID number to be used by this coroutine. If <0,
 an error occurred -- the ID requested was already in use, or we
 couldn't assign one without going over the "unreasonable value" mark</dd>
</dl>
</li>
</ul>
<a name="co_entry_pause-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>co_entry_pause</h4>
<pre>public&nbsp;java.lang.Object&nbsp;co_entry_pause(int&nbsp;thisCoroutine)
                                throws java.lang.NoSuchMethodException</pre>
<div class="block">In the standard coroutine architecture, coroutines are
 identified by their method names and are launched and run up to
 their first yield by simply resuming them; its's presumed that
 this recognizes the not-already-running case and does the right
 thing. We seem to need a way to achieve that same threadsafe
 run-up...  eg, start the coroutine with a wait.

 %TBD% whether this makes any sense...</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>thisCoroutine</code> - the identifier of this coroutine, so we can
 recognize when we are being resumed.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.NoSuchMethodException</code> - if thisCoroutine isn't
 a registered member of this group. %REVIEW% whether this is the
 best choice.</dd>
</dl>
</li>
</ul>
<a name="co_resume-java.lang.Object-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>co_resume</h4>
<pre>public&nbsp;java.lang.Object&nbsp;co_resume(java.lang.Object&nbsp;arg_object,
                                  int&nbsp;thisCoroutine,
                                  int&nbsp;toCoroutine)
                           throws java.lang.NoSuchMethodException</pre>
<div class="block">Transfer control to another coroutine which has already been started and
 is waiting on this CoroutineManager. We won't return from this call
 until that routine has relinquished control.

 %TBD% What should we do if toCoroutine isn't registered? Exception?</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>arg_object</code> - A value to be passed to the other coroutine.</dd>
<dd><code>thisCoroutine</code> - Integer identifier for this coroutine. This is the
 ID we watch for to see if we're the ones being resumed.</dd>
<dd><code>toCoroutine</code> - Integer identifier for the coroutine we wish to
 invoke.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.NoSuchMethodException</code> - if toCoroutine isn't a
 registered member of this group. %REVIEW% whether this is the best choice.</dd>
</dl>
</li>
</ul>
<a name="co_exit-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>co_exit</h4>
<pre>public&nbsp;void&nbsp;co_exit(int&nbsp;thisCoroutine)</pre>
<div class="block">Terminate this entire set of coroutines. The others will be
 deregistered and have exceptions thrown at them. Note that this
 is intended as a panic-shutdown operation; under normal
 circumstances a coroutine should always end with co_exit_to() in
 order to politely inform at least one of its partners that it is
 going away.

 %TBD% This may need significantly more work. 

 %TBD% Should this just be co_exit_to(,,CoroutineManager.PANIC)?</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>thisCoroutine</code> - Integer identifier for the coroutine requesting exit.</dd>
</dl>
</li>
</ul>
<a name="co_exit_to-java.lang.Object-int-int-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>co_exit_to</h4>
<pre>public&nbsp;void&nbsp;co_exit_to(java.lang.Object&nbsp;arg_object,
                       int&nbsp;thisCoroutine,
                       int&nbsp;toCoroutine)
                throws java.lang.NoSuchMethodException</pre>
<div class="block">Make the ID available for reuse and terminate this coroutine,
 transferring control to the specified coroutine. Note that this
 returns immediately rather than waiting for any further coroutine
 traffic, so the thread can proceed with other shutdown activities.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>arg_object</code> - A value to be passed to the other coroutine.</dd>
<dd><code>thisCoroutine</code> - Integer identifier for the coroutine leaving the set.</dd>
<dd><code>toCoroutine</code> - Integer identifier for the coroutine we wish to
 invoke.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.NoSuchMethodException</code> - if toCoroutine isn't a
 registered member of this group. %REVIEW% whether this is the best choice.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../../../org/apache/xml/dtm/ref/CoroutineParser.html" title="interface in org.apache.xml.dtm.ref"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?org/apache/xml/dtm/ref/CoroutineManager.html" target="_top">Frames</a></li>
<li><a href="CoroutineManager.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
